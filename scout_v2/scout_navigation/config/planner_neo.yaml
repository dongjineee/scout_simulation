controller_frequency: 5.0
recovery_behaviour_enabled: true

NavfnROS:
  allow_unknown: true
  #Specifies whether or not to allow the planner to create plans that traverse unknown space. 
  #NOTE: if you are using a layered costmap_2d costmap with a voxel or obstacle layer, 
  #you must also set the track_unknown_space param for that layer to be true, 
  #or it will convert all your unknown space to free space (which planner will then happily go right through). 
  #(bool, default: true)

  default_tolerance: 0.0
  #A tolerance on the goal point for the planner. The planner will attempt to create a plan that is as close to 
  #the specified goal as possible but no further than default_tolerance away.
  #(double, default: 0.0)

  visualize_potential: false
  #Specifies whether or not to visualize the potential area computed via a PointCloud2.
  #(bool, default: false)

  use_dijkstra: true
  #If true, use dijkstra's algorithm. Otherwise, A*.
  #(bool, default: true)

  use_quadratic: true
  #If true, use the quadratic approximation of the potential. Otherwise, use a simpler calculation.
  #(bool, default: true)

  use_grid_path: false
  #If true, create a path that follows the grid boundaries. Otherwise, use a gradient descent method.
  #(bool, default: false)

  old_navfn_behavior: false
  #If for some reason, you want global_planner to exactly mirror the behavior of navfn, 
  #set this to true (and use the defaults for the other boolean parameters)
  #(bool, default: false)

  lethal_cost: 253 
  #Lethal Cost (dynamic reconfigure) (int, default: 253)

  neutral_cost: 50
  #Neutral Cost (dynamic reconfigure) (int, default: 50)

  cost_factor: 3.0
  #Factor to multiply each cost from costmap by (dynamic reconfigure) (double, default: 3.)

  publish_potential: true
  #Publish Potential Costmap (dynamic reconfigure) (bool, default: True)

  orientation_mode: 4
  #How to set the orientation of each point 
  #(None=0, Forward=1, Interpolate=2, ForwardThenInterpolate=3, Backward=4, Leftward=5, Rightward=6) (dynamic reconfigure)
  #(int, default: 0)

  orientation_window_size: 10
  #What window to use to determine the orientation based on the position derivative specified by the orientation mode (dynamic reconfigure)
  #(int, default: 1)

NeoLocalPlanner:

  # The x acceleration limit of the robot in meters/sec^2
  acc_lim_x : 0.35

  # The rotational acceleration limit of the robot in radians/sec^2
  acc_lim_theta : 0.4

  # The maximum x velocity for the robot in m/s.
  max_vel_x : 0.8

  # The minimum x velocity for the robot in m/s, negative for backwards motion.
  min_vel_x : -0.4

  # The absolute value of the maximum rotational velocity for the robot in rad/s
  max_rot_vel : 0.45

  # The absolute value of the minimum rotational velocity for the robot in rad/s
  min_rot_vel : 0.15

  # The absolute value of the maximum translational velocity for the robot in m/s
  max_trans_vel : 0.6

  # The absolute value of the minimum translational velocity for the robot in m/s
  min_trans_vel : 0.1

  # The tolerance in radians for the controller in yaw/rotation when achieving its goal
  yaw_goal_tolerance : 0.5

  # The tolerance in meters for the controller in the x & y distance when achieving a goal
  xy_goal_tolerance : 0.15

  # How long to fine tune for goal position after reaching tolerance limits [s]
  goal_tune_time : 0

  # How far to predict control pose into the future based on latest odometry [s]
  lookahead_time : 0.8

  # How far to look ahead when computing path orientation [m]
  lookahead_dist : 0.8

  # Threshold yaw error below which we consider to start moving [rad]
  start_yaw_error : 0.3

  # Gain when adjusting final x position for goal [1/s]
  pos_x_gain : 1

  # Gain for lane keeping based on y error (differential only) [rad/s^2]
  pos_y_yaw_gain : 2

  # Gain for lane keeping based on yaw error (differential only) [1/s]
  yaw_gain : 4

  # Gain for adjusting yaw when not translating, or in case of holonomic drive  [1/s]
  static_yaw_gain : 5

  # Gain for y cost avoidance (differential only)
  cost_y_yaw_gain : 0.3

  # How far ahead to compute y cost gradient (constant offset) [m]
  cost_y_lookahead_dist : 0.3

  # How far ahead to compute y cost gradient (dynamic offset) [s]
  cost_y_lookahead_time : 1.5

  # Gain for yaw cost avoidance
  cost_yaw_gain : 2

  # Gain for final control low pass filter
  low_pass_gain : 0.2

  # Max cost to allow, above we slow down to min_trans_vel or even stop
  max_cost : 0.95

  # Max velocity based on curvature [rad/s]
  max_curve_vel : 0.4

  # Max distance to goal when looking for it [m]
  max_goal_dist : 0.3

  # Max distance allowable for backing up (zero = unlimited) [m]
  max_backup_dist : 0.1

  # Minimal distance for stopping [m]
  min_stop_dist : 0.4

  # If robot has differential drive, holonomic otherwise
  differential_drive : true
